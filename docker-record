#!/usr/bin/env python
# vim: set ts=4; shiftwidth=4; expandtab
"""docker-record

Usage:
  docker-record <CONTAINER>
  docker-record <CONTAINER> --replay
"""
from docker import Client
from docopt import docopt
import io
import os
import sys
import tarfile

## record

SESSION_TEMPLATE = """bash --init-file <(echo '{instrumentation}')"""
INSTRUMENTATION = '''
SESSION_ROOT=/tmp/record;
mkdir -p $SESSION_ROOT;
function __instrument() {
  echo $EUID >> $SESSION_ROOT/euid &&
  echo $BASH_COMMAND >> $SESSION_ROOT/cmd &&
  echo $PWD >> $SESSION_ROOT/pwd &&
  echo $(export | tr "\\n" ";") >> $SESSION_ROOT/env ||
  exit;
};
shopt -s extdebug;
trap __instrument DEBUG;'''
SESSION_COMMAND = SESSION_TEMPLATE.format(instrumentation = INSTRUMENTATION.replace('\n', ' '))

def record(container):
    os.execlp('docker', 'docker', 'exec', '-ti', container, 'bash', '-c', SESSION_COMMAND)

## replay

# make it work now, refactor later
SESSION_PATH = '/tmp/record/{filename}'
COMMAND_FILENAME = 'cmd'
ENVIRONMENT_FILENAME = 'env'
WORKDIR_FILENAME = 'pwd'

BUILD_CONTEXT_PATH = './build/'

# these commands from the history should not be included in the Dockerfile
COMMAND_BLACKLIST = ['ls', 'cd', 'pwd', 'history', 'du',
                     'exit', 'clear', 'git status', 'cat']

# Heuristic: these commands are likely to be "service"
DOCKER_CMD_WHITELIST = ['service', '/etc/init.d/']

# Heuristic: add files that were opened by an editor
EDITOR_WHITELIST = ['nano', 'vim', 'emacs', 'joe']

def replay(container):

    commands = read_session(container, COMMAND_FILENAME)
    environments = read_session(container, ENVIRONMENT_FILENAME)
    workdirs = read_session(container, WORKDIR_FILENAME)

    dockerfile = []

    fs_changes = filesystem_diff(container)

    # Extract RUN and CMD directives from our history logs into the Dockerfile
    for command, environment, workdir in zip(commands, environments, workdirs):

        if is_blacklisted(command):
            continue

        if is_docker_cmd(command):
            dockerfile.append("CMD " + command)
        elif is_editor(command):
            # now check whether the file was actually created/changed in the FS
            print command
            changed_path = extract_path_from_editor_command(command)
            print changed_path
            if changed_in_filesystem(fs_changes, changed_path):
                if changed_path.startswith('/'):
                    source_path = changed_path
                else:
                    source_path = workdir + "/" + changed_path

                copy_from_container(container, source_path, BUILD_CONTEXT_PATH + flatten_path(source_path))
                local_file = "path/to/local/file"
                dockerfile.append("ADD " + local_file + " " + changed_path)
        else:
            dockerfile.append("RUN " + command)


    for instruction in dockerfile:
        print instruction


def copy_from_container(container, source, destination):
    file_contents = copy(container, source)
    with open(destination, 'w') as f:
        f.write(file_contents)

def flatten_path(path):
    return path.replace('/', '_')

def changed_in_filesystem(fs_changes, filename):
    # ignore the Kind parameter for now
    return filename in fs_changes

def filesystem_diff(container):
    client = Client()
    raw_changes = client.diff(container)
    changes = {}
    for raw_change in raw_changes:
        changes[raw_change['Path']] = raw_change['Kind']
    return changes

def extract_path_from_editor_command(command):
    command.split(' ')[1]

def read_session(container, filename):
    return copy(container, SESSION_PATH.format(filename = filename))

def is_docker_cmd(command):
    for docker_cmd_command in DOCKER_CMD_WHITELIST:
        if command.startswith(docker_cmd_command):
            return True
    return False

def is_editor(command):
    for editor in EDITOR_WHITELIST:
        if command.startswith(editor):
            return True
    return False

def is_blacklisted(command):
    for blacklisted_command in COMMAND_BLACKLIST:
        if command.startswith(blacklisted_command):
            return True
    return False

def copy(container, path):
    client = Client()
    response = client.copy(container, path)
    buffer = io.BytesIO()
    buffer.write(response.data)
    buffer.seek(0)
    tar = tarfile.open(fileobj=buffer, mode='r')
    for member in tar.getmembers():
        return tar.extractfile(member).readlines()

if __name__ == '__main__':

    arguments = docopt(__doc__, version='docker-record 1.0')
    container = arguments['<CONTAINER>']

    if arguments['--replay']:
        replay(container)
    else:
        record(container)

