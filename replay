#!/usr/bin/env python
# vim: set ts=4; shiftwidth=4; expandtab

import sys
from docker import Client

# make it work now, refactor later
SESSION_PATH = 'sessions/{container}/record/'
COMMAND_FILENAME = 'cmd'
ENVIRONMENT_FILENAME = 'env'
WORKDIR_FILENAME = 'pwd'

BUILD_CONTEXT_PATH = './build/'

# these commands from the history should not be included in the Dockerfile
COMMAND_BLACKLIST = ['ls', 'cd', 'pwd', 'history', 'du', 
                     'exit', 'clear', 'git status', 'cat']

# Heuristic: these commands are likely to be "service"
DOCKER_CMD_WHITELIST = ['service', '/etc/init.d/']

# Heuristic: add files that were opened by an editor
EDITOR_WHITELIST = ['nano', 'vim', 'emacs', 'joe']

def main():
    container = sys.argv[1]
    
    commands = read_session(container, COMMAND_FILENAME)
    environments = read_session(container, ENVIRONMENT_FILENAME)
    workdirs = read_session(container, WORKDIR_FILENAME)

    dockerfile = []

    fs_changes = filesystem_diff(container)

    # Extract RUN and CMD directives from our history logs into the Dockerfile
    for command, environment, workdir in zip(commands, environments, workdirs):
        
        if is_blacklisted(command):
            continue

        if is_docker_cmd(command):
            dockerfile.append("CMD " + command)
        elif is_editor(command):
            # now check whether the file was actually created/changed in the FS
            print command
            changed_path = extract_path_from_editor_command(command)
            print changed_path
            if changed_in_filesystem(fs_changes, changed_path):
                if changed_path.startswith('/'):
                    source_path = changed_path
                else:
                    source_path = workdir + "/" + changed_path

                copy_from_container(container, source_path, BUILD_CONTEXT_PATH + flatten_path(source_path))
                local_file = "path/to/local/file"
                dockerfile.append("ADD " + local_file + " " + changed_path)
        else:
            dockerfile.append("RUN " + command)
    

    for instruction in dockerfile:
        print instruction




def copy_from_container(container, source, destination):
    client = Client()
    file_contents = client.copy(container, source)
    with open(destination, 'w') as f:
        f.write(file_contents)
                
def flatten_path(path):
    return path.replace('/', '_')

def changed_in_filesystem(fs_changes, filename):
    # ignore the Kind parameter for now
    return filename in fs_changes

def filesystem_diff(container):
    client = Client()
    raw_changes = client.diff(container)
    changes = {}
    for raw_change in raw_changes:
        changes[raw_change['Path']] = raw_change['Kind']
    return changes

def extract_path_from_editor_command(command):
    command.split(' ')[1]

def read_session(container, filename):
    session_path = SESSION_PATH.format(container = container)
    with open(session_path + filename, "r") as f: 
        return f.readlines()

def is_docker_cmd(command):
    for docker_cmd_command in DOCKER_CMD_WHITELIST:
        if command.startswith(docker_cmd_command):
            return True
    return False

def is_editor(command):
    for editor in EDITOR_WHITELIST:
        if command.startswith(editor):
            return True
    return False



def is_blacklisted(command):
    for blacklisted_command in COMMAND_BLACKLIST:
        if command.startswith(blacklisted_command):
            return True
    return False

if __name__ == '__main__':
    main()
